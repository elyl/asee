- L'image debian est dans /kvm/debian32.img
- Le build dans /build/kvm32 ne marche pas, il build dans le repertoire racine
- Le mount ne marche pas, necessite sudo

Etat du module:
- Initialisation OK
- show file fonctionnel mais pas bonne sortie
- Recuperation temps execution OK
- write file OK
- Recherche de PID OK
- Detecter la mort d'un PID; Devrait etre OK, pas encore test
- Gerer le cas ou le PID est invalide. (Facile, suffit de verifier la sortie de find_vpid(), en cas de NULL le PID est invalide) OK
- Gerer plusieurs PID EC (tableau de struct pid, a vider a chaque mort de PID; Ajouter un compteur de monitoring, evite un parcour de tableau en cas d'ajout) OK
- Creer le repertoire /proc/ase (code mais ne marche pas, raison inconnue) OK
- Lire le fichier ? OK

A faire:
- Ajouter un mutex 
- Instruction de fin de monitoring (quelque chose genre <PID 1> pour lancer le monitoring et <PID 0> pour le stopper)
- Trouver comment obtenir temps d'exec par core (Semble devoir etre fait a la main en porbant le scheduler(Flemme))
- Gerer plusieurs fichiers EC
- Basculer la lecture sur la nouvelle structure
- Basculer l'écriture sur la nouvelle structure
- Remplacer ase_cmd_buffer par un buffer local en parametre de ase_cmd_new_file

Recherches:
mettre un prob dans do_sched_setScheduler; core.c:3705
ne pas faire de printk avant seq_printf, sinon le seq_printf ne s'execute pas

TIME:
include/linux/sched.h:534
struct cputime -> Contient le temps d'execution de la task en mode systeme et en mode user
cputime_t utime, stime : Respectivement temps user et temps system

include/linux/sched.h:553
struct task_cputime -> Extension de la structure precedente pour traquer egalement le temps global (la somme des deux precedents)
cputime_t utime, stime : Respectivement temps user et system, sans interets dans le cas present
unsigned long long sum_exec_runtime : Temps global, celui qui nous interesse

include/linux/cputime.h:7 cputime_to_nsecs
Macro pour convertir un cputime_t en usecs

TASK:
include/linux/sched.h:1293 task_struct
Tres grosse structure definissant une task au sein du scheduler, beaucoup trop de parametres pour la detailler. Ceux qui nous interessent ici sont:
pid_t pid: PID de la task. (Line 1394)
struct task_cputime cputime_expires: Surement un rapport avec le temps d'exec mais aucune idee duquel(NOTE: Ceci est une structure et non pas un pointeur sur une structure)(Line 1452)
cputime_t utime, stime : Temps d'execution system et user.(Line 1432)


PID:
include/linux/pid.h:57 struct pid
Structure representant un PID, sans grand interet pour le projet courant a priori

include/linux/pid.h:6 pid_type
enum pid_type -> Differents types de PID, necessaire pour les recherches de PID/Task
Celui qui nous interesse est PIDTYPE_PID

include/linux/pid.h:83 pid_task
struct task_struct *pid_task -> Retourne un pointeur vers la struct task_struct associee au PID en parametre
struct pid *pid: Pointeur vers la struct pid associee a la task recherchee.
pid_type: Type de PID. PIDTYPE_PID dans le cas present.

include/linux/pid.h:111 find_vpid
struct pid *find_vpid -> Retourne un pointeur vers la struct pid associee au numero de PID passee en parametre
int nr: Numéro du pid
ATTENTION:     Necessite la prise de verrou en lecture, rcu_read_lock() et rcu_read_unlock()
	       (Je n'ai pas trouve le fichier de definition de ces fonctions pour le moment)
	       (Lire commentaire include/linux/pid.h:102 pour plus de details)

include/linux/pid.h:84 get_pid_task
struct task_struct *get_pid_task -> Retourne un pointeur vers la struct task_struct associee a la struct pid
struct pid *pid: Pointeur vers la struct pid recherchee
enum pid_type type: Type de PID. Ici PIDTYPE_PID

NOTE:	  Il est important d'utiliser un pointeur vers la struct pid plutot que le PID lui meme, la struct sera toujours propre au job que l'on traque contrairement au PID qui peut etre reaatribue par le kernel eventuellement.
	  Utiliser un pointeur vers la struct task_task est une mauvaise idee car elle sera eventuellement liberee par le kernel provoquant un NULL pointer tandis que la struct pid est conservee. La recherche de struct task_struct renverra simplement NULL ce qui est detectable.
	  (Lire commentaire dans include/linux/pid.h:15 pour plus d'infos)
	  (Est il utile de dire pourquoi un pointeur plutot qu'une copie?)
	  (Il semble etrange tout de même que le systeme garde en memoire une trace de tous les PID (meme si 64bytes font tres peu au final. Il doit y avoir un mecanisme de nettoyage automatique quelque part)

UTILS:
include/linux/kernel.h:318 kstrtol
int kstrtol: Convertit une chaine du userspace en int dans la base de notre choix (ici 10). Fonction optimise a prefere aux autres.
const char *s: Chaine a convertir, attention elle doit etre dans l'userspace.
unsigned int base: Base dans laquelle est ecrite le nombre, mettre 0 pour des raisons d'optimisations
long *res : Pointeur vers la variable qui contiendra le resultat de l'operation

SEQ:
include/linux/seq_file.h:18 struct seq_file
Structure definissant un seq file, 
include/linux/user_namespace.h:25 struct user_namespace
Contient des infos sur les user_namespace, semble etre une fausse piste dans la recherche du nom du seq file courant.

http://lxr.free-electrons.com/source/include/linux/proc_fs.h#L64

RESOURCES:
http://tuxthink.blogspot.fr/2012/01/creating-folder-under-proc-and-creating.html
http://stackoverflow.com/questions/7973992/finding-amount-of-cpu-time-process-spent-in-kernel-routines
http://stackoverflow.com/questions/7973992/finding-amount-of-cpu-time-process-spent-in-kernel-routines
http://stackoverflow.com/questions/7973992/finding-amount-of-cpu-time-process-spent-in-kernel-routines
https://www.kernel.org/doc/Documentation/filesystems/seq_file.txt
http://tuxthink.blogspot.fr/2013/10/creation-of-proc-entrt-using.html